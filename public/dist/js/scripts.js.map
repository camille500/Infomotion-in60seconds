{"version":3,"sources":["jquery-sortable.js","jquery-touchpunch.js","userdata.js","main.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjsBA;ACAA;AACA;AACA;AACA;AACA;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"scripts.js","sourcesContent":["/* ===================================================\n *  jquery-sortable.js v0.9.13\n *  http://johnny.github.com/jquery-sortable/\n * ===================================================\n *  Copyright (c) 2012 Jonas von Andrian\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  * The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * ========================================================== */\n\n\n!function ( $, window, pluginName, undefined){\n  var containerDefaults = {\n    // If true, items can be dragged from this container\n    drag: true,\n    // If true, items can be droped onto this container\n    drop: true,\n    // Exclude items from being draggable, if the\n    // selector matches the item\n    exclude: \"\",\n    // If true, search for nested containers within an item.If you nest containers,\n    // either the original selector with which you call the plugin must only match the top containers,\n    // or you need to specify a group (see the bootstrap nav example)\n    nested: true,\n    // If true, the items are assumed to be arranged vertically\n    vertical: true\n  }, // end container defaults\n  groupDefaults = {\n    // This is executed after the placeholder has been moved.\n    // $closestItemOrContainer contains the closest item, the placeholder\n    // has been put at or the closest empty Container, the placeholder has\n    // been appended to.\n    afterMove: function ($placeholder, container, $closestItemOrContainer) {\n    },\n    // The exact css path between the container and its items, e.g. \"> tbody\"\n    containerPath: \"\",\n    // The css selector of the containers\n    containerSelector: \"ol, ul\",\n    // Distance the mouse has to travel to start dragging\n    distance: 0,\n    // Time in milliseconds after mousedown until dragging should start.\n    // This option can be used to prevent unwanted drags when clicking on an element.\n    delay: 0,\n    // The css selector of the drag handle\n    handle: \"\",\n    // The exact css path between the item and its subcontainers.\n    // It should only match the immediate items of a container.\n    // No item of a subcontainer should be matched. E.g. for ol>div>li the itemPath is \"> div\"\n    itemPath: \"\",\n    // The css selector of the items\n    itemSelector: \"li\",\n    // The class given to \"body\" while an item is being dragged\n    bodyClass: \"dragging\",\n    // The class giving to an item while being dragged\n    draggedClass: \"dragged\",\n    // Check if the dragged item may be inside the container.\n    // Use with care, since the search for a valid container entails a depth first search\n    // and may be quite expensive.\n    isValidTarget: function ($item, container) {\n      return true\n    },\n    // Executed before onDrop if placeholder is detached.\n    // This happens if pullPlaceholder is set to false and the drop occurs outside a container.\n    onCancel: function ($item, container, _super, event) {\n    },\n    // Executed at the beginning of a mouse move event.\n    // The Placeholder has not been moved yet.\n    onDrag: function ($item, position, _super, event) {\n      $item.css(position)\n    },\n    // Called after the drag has been started,\n    // that is the mouse button is being held down and\n    // the mouse is moving.\n    // The container is the closest initialized container.\n    // Therefore it might not be the container, that actually contains the item.\n    onDragStart: function ($item, container, _super, event) {\n      $item.css({\n        height: $item.outerHeight(),\n        width: $item.outerWidth()\n      })\n      $item.addClass(container.group.options.draggedClass)\n      $(\"body\").addClass(container.group.options.bodyClass)\n    },\n    // Called when the mouse button is being released\n    onDrop: function ($item, container, _super, event) {\n      $item.removeClass(container.group.options.draggedClass).removeAttr(\"style\")\n      $(\"body\").removeClass(container.group.options.bodyClass)\n    },\n    // Called on mousedown. If falsy value is returned, the dragging will not start.\n    // Ignore if element clicked is input, select or textarea\n    onMousedown: function ($item, _super, event) {\n      if (!event.target.nodeName.match(/^(input|select|textarea)$/i)) {\n        event.preventDefault()\n        return true\n      }\n    },\n    // The class of the placeholder (must match placeholder option markup)\n    placeholderClass: \"placeholder\",\n    // Template for the placeholder. Can be any valid jQuery input\n    // e.g. a string, a DOM element.\n    // The placeholder must have the class \"placeholder\"\n    placeholder: '<li class=\"placeholder\"></li>',\n    // If true, the position of the placeholder is calculated on every mousemove.\n    // If false, it is only calculated when the mouse is above a container.\n    pullPlaceholder: true,\n    // Specifies serialization of the container group.\n    // The pair $parent/$children is either container/items or item/subcontainers.\n    serialize: function ($parent, $children, parentIsContainer) {\n      var result = $.extend({}, $parent.data())\n\n      if(parentIsContainer)\n        return [$children]\n      else if ($children[0]){\n        result.children = $children\n      }\n\n      delete result.subContainers\n      delete result.sortable\n\n      return result\n    },\n    // Set tolerance while dragging. Positive values decrease sensitivity,\n    // negative values increase it.\n    tolerance: 0\n  }, // end group defaults\n  containerGroups = {},\n  groupCounter = 0,\n  emptyBox = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right:0\n  },\n  eventNames = {\n    start: \"touchstart.sortable mousedown.sortable\",\n    drop: \"touchend.sortable touchcancel.sortable mouseup.sortable\",\n    drag: \"touchmove.sortable mousemove.sortable\",\n    scroll: \"scroll.sortable\"\n  },\n  subContainerKey = \"subContainers\"\n\n  /*\n   * a is Array [left, right, top, bottom]\n   * b is array [left, top]\n   */\n  function d(a,b) {\n    var x = Math.max(0, a[0] - b[0], b[0] - a[1]),\n    y = Math.max(0, a[2] - b[1], b[1] - a[3])\n    return x+y;\n  }\n\n  function setDimensions(array, dimensions, tolerance, useOffset) {\n    var i = array.length,\n    offsetMethod = useOffset ? \"offset\" : \"position\"\n    tolerance = tolerance || 0\n\n    while(i--){\n      var el = array[i].el ? array[i].el : $(array[i]),\n      // use fitting method\n      pos = el[offsetMethod]()\n      pos.left += parseInt(el.css('margin-left'), 10)\n      pos.top += parseInt(el.css('margin-top'),10)\n      dimensions[i] = [\n        pos.left - tolerance,\n        pos.left + el.outerWidth() + tolerance,\n        pos.top - tolerance,\n        pos.top + el.outerHeight() + tolerance\n      ]\n    }\n  }\n\n  function getRelativePosition(pointer, element) {\n    var offset = element.offset()\n    return {\n      left: pointer.left - offset.left,\n      top: pointer.top - offset.top\n    }\n  }\n\n  function sortByDistanceDesc(dimensions, pointer, lastPointer) {\n    pointer = [pointer.left, pointer.top]\n    lastPointer = lastPointer && [lastPointer.left, lastPointer.top]\n\n    var dim,\n    i = dimensions.length,\n    distances = []\n\n    while(i--){\n      dim = dimensions[i]\n      distances[i] = [i,d(dim,pointer), lastPointer && d(dim, lastPointer)]\n    }\n    distances = distances.sort(function  (a,b) {\n      return b[1] - a[1] || b[2] - a[2] || b[0] - a[0]\n    })\n\n    // last entry is the closest\n    return distances\n  }\n\n  function ContainerGroup(options) {\n    this.options = $.extend({}, groupDefaults, options)\n    this.containers = []\n\n    if(!this.options.rootGroup){\n      this.scrollProxy = $.proxy(this.scroll, this)\n      this.dragProxy = $.proxy(this.drag, this)\n      this.dropProxy = $.proxy(this.drop, this)\n      this.placeholder = $(this.options.placeholder)\n\n      if(!options.isValidTarget)\n        this.options.isValidTarget = undefined\n    }\n  }\n\n  ContainerGroup.get = function  (options) {\n    if(!containerGroups[options.group]) {\n      if(options.group === undefined)\n        options.group = groupCounter ++\n\n      containerGroups[options.group] = new ContainerGroup(options)\n    }\n\n    return containerGroups[options.group]\n  }\n\n  ContainerGroup.prototype = {\n    dragInit: function  (e, itemContainer) {\n      this.$document = $(itemContainer.el[0].ownerDocument)\n\n      // get item to drag\n      var closestItem = $(e.target).closest(this.options.itemSelector);\n      // using the length of this item, prevents the plugin from being started if there is no handle being clicked on.\n      // this may also be helpful in instantiating multidrag.\n      if (closestItem.length) {\n        this.item = closestItem;\n        this.itemContainer = itemContainer;\n        if (this.item.is(this.options.exclude) || !this.options.onMousedown(this.item, groupDefaults.onMousedown, e)) {\n            return;\n        }\n        this.setPointer(e);\n        this.toggleListeners('on');\n        this.setupDelayTimer();\n        this.dragInitDone = true;\n      }\n    },\n    drag: function  (e) {\n      if(!this.dragging){\n        if(!this.distanceMet(e) || !this.delayMet)\n          return\n\n        this.options.onDragStart(this.item, this.itemContainer, groupDefaults.onDragStart, e)\n        this.item.before(this.placeholder)\n        this.dragging = true\n      }\n\n      this.setPointer(e)\n      // place item under the cursor\n      this.options.onDrag(this.item,\n                          getRelativePosition(this.pointer, this.item.offsetParent()),\n                          groupDefaults.onDrag,\n                          e)\n\n      var p = this.getPointer(e),\n      box = this.sameResultBox,\n      t = this.options.tolerance\n\n      if(!box || box.top - t > p.top || box.bottom + t < p.top || box.left - t > p.left || box.right + t < p.left)\n        if(!this.searchValidTarget()){\n          this.placeholder.detach()\n          this.lastAppendedItem = undefined\n        }\n    },\n    drop: function  (e) {\n      this.toggleListeners('off')\n\n      this.dragInitDone = false\n\n      if(this.dragging){\n        // processing Drop, check if placeholder is detached\n        if(this.placeholder.closest(\"html\")[0]){\n          this.placeholder.before(this.item).detach()\n        } else {\n          this.options.onCancel(this.item, this.itemContainer, groupDefaults.onCancel, e)\n        }\n        this.options.onDrop(this.item, this.getContainer(this.item), groupDefaults.onDrop, e)\n\n        // cleanup\n        this.clearDimensions()\n        this.clearOffsetParent()\n        this.lastAppendedItem = this.sameResultBox = undefined\n        this.dragging = false\n      }\n    },\n    searchValidTarget: function  (pointer, lastPointer) {\n      if(!pointer){\n        pointer = this.relativePointer || this.pointer\n        lastPointer = this.lastRelativePointer || this.lastPointer\n      }\n\n      var distances = sortByDistanceDesc(this.getContainerDimensions(),\n                                         pointer,\n                                         lastPointer),\n      i = distances.length\n\n      while(i--){\n        var index = distances[i][0],\n        distance = distances[i][1]\n\n        if(!distance || this.options.pullPlaceholder){\n          var container = this.containers[index]\n          if(!container.disabled){\n            if(!this.$getOffsetParent()){\n              var offsetParent = container.getItemOffsetParent()\n              pointer = getRelativePosition(pointer, offsetParent)\n              lastPointer = getRelativePosition(lastPointer, offsetParent)\n            }\n            if(container.searchValidTarget(pointer, lastPointer))\n              return true\n          }\n        }\n      }\n      if(this.sameResultBox)\n        this.sameResultBox = undefined\n    },\n    movePlaceholder: function  (container, item, method, sameResultBox) {\n      var lastAppendedItem = this.lastAppendedItem\n      if(!sameResultBox && lastAppendedItem && lastAppendedItem[0] === item[0])\n        return;\n\n      item[method](this.placeholder)\n      this.lastAppendedItem = item\n      this.sameResultBox = sameResultBox\n      this.options.afterMove(this.placeholder, container, item)\n    },\n    getContainerDimensions: function  () {\n      if(!this.containerDimensions)\n        setDimensions(this.containers, this.containerDimensions = [], this.options.tolerance, !this.$getOffsetParent())\n      return this.containerDimensions\n    },\n    getContainer: function  (element) {\n      return element.closest(this.options.containerSelector).data(pluginName)\n    },\n    $getOffsetParent: function  () {\n      if(this.offsetParent === undefined){\n        var i = this.containers.length - 1,\n        offsetParent = this.containers[i].getItemOffsetParent()\n\n        if(!this.options.rootGroup){\n          while(i--){\n            if(offsetParent[0] != this.containers[i].getItemOffsetParent()[0]){\n              // If every container has the same offset parent,\n              // use position() which is relative to this parent,\n              // otherwise use offset()\n              // compare #setDimensions\n              offsetParent = false\n              break;\n            }\n          }\n        }\n\n        this.offsetParent = offsetParent\n      }\n      return this.offsetParent\n    },\n    setPointer: function (e) {\n      var pointer = this.getPointer(e)\n\n      if(this.$getOffsetParent()){\n        var relativePointer = getRelativePosition(pointer, this.$getOffsetParent())\n        this.lastRelativePointer = this.relativePointer\n        this.relativePointer = relativePointer\n      }\n\n      this.lastPointer = this.pointer\n      this.pointer = pointer\n    },\n    distanceMet: function (e) {\n      var currentPointer = this.getPointer(e)\n      return (Math.max(\n        Math.abs(this.pointer.left - currentPointer.left),\n        Math.abs(this.pointer.top - currentPointer.top)\n      ) >= this.options.distance)\n    },\n    getPointer: function(e) {\n      var o = e.originalEvent || e.originalEvent.touches && e.originalEvent.touches[0]\n      return {\n        left: e.pageX || o.pageX,\n        top: e.pageY || o.pageY\n      }\n    },\n    setupDelayTimer: function () {\n      var that = this\n      this.delayMet = !this.options.delay\n\n      // init delay timer if needed\n      if (!this.delayMet) {\n        clearTimeout(this._mouseDelayTimer);\n        this._mouseDelayTimer = setTimeout(function() {\n          that.delayMet = true\n        }, this.options.delay)\n      }\n    },\n    scroll: function  (e) {\n      this.clearDimensions()\n      this.clearOffsetParent() // TODO is this needed?\n    },\n    toggleListeners: function (method) {\n      var that = this,\n      events = ['drag','drop','scroll']\n\n      $.each(events,function  (i,event) {\n        that.$document[method](eventNames[event], that[event + 'Proxy'])\n      })\n    },\n    clearOffsetParent: function () {\n      this.offsetParent = undefined\n    },\n    // Recursively clear container and item dimensions\n    clearDimensions: function  () {\n      this.traverse(function(object){\n        object._clearDimensions()\n      })\n    },\n    traverse: function(callback) {\n      callback(this)\n      var i = this.containers.length\n      while(i--){\n        this.containers[i].traverse(callback)\n      }\n    },\n    _clearDimensions: function(){\n      this.containerDimensions = undefined\n    },\n    _destroy: function () {\n      containerGroups[this.options.group] = undefined\n    }\n  }\n\n  function Container(element, options) {\n    this.el = element\n    this.options = $.extend( {}, containerDefaults, options)\n\n    this.group = ContainerGroup.get(this.options)\n    this.rootGroup = this.options.rootGroup || this.group\n    this.handle = this.rootGroup.options.handle || this.rootGroup.options.itemSelector\n\n    var itemPath = this.rootGroup.options.itemPath\n    this.target = itemPath ? this.el.find(itemPath) : this.el\n\n    this.target.on(eventNames.start, this.handle, $.proxy(this.dragInit, this))\n\n    if(this.options.drop)\n      this.group.containers.push(this)\n  }\n\n  Container.prototype = {\n    dragInit: function  (e) {\n      var rootGroup = this.rootGroup\n\n      if( !this.disabled &&\n          !rootGroup.dragInitDone &&\n          this.options.drag &&\n          this.isValidDrag(e)) {\n        rootGroup.dragInit(e, this)\n      }\n    },\n    isValidDrag: function(e) {\n      return e.which == 1 ||\n        e.type == \"touchstart\" && e.originalEvent.touches.length == 1\n    },\n    searchValidTarget: function  (pointer, lastPointer) {\n      var distances = sortByDistanceDesc(this.getItemDimensions(),\n                                         pointer,\n                                         lastPointer),\n      i = distances.length,\n      rootGroup = this.rootGroup,\n      validTarget = !rootGroup.options.isValidTarget ||\n        rootGroup.options.isValidTarget(rootGroup.item, this)\n\n      if(!i && validTarget){\n        rootGroup.movePlaceholder(this, this.target, \"append\")\n        return true\n      } else\n        while(i--){\n          var index = distances[i][0],\n          distance = distances[i][1]\n          if(!distance && this.hasChildGroup(index)){\n            var found = this.getContainerGroup(index).searchValidTarget(pointer, lastPointer)\n            if(found)\n              return true\n          }\n          else if(validTarget){\n            this.movePlaceholder(index, pointer)\n            return true\n          }\n        }\n    },\n    movePlaceholder: function  (index, pointer) {\n      var item = $(this.items[index]),\n      dim = this.itemDimensions[index],\n      method = \"after\",\n      width = item.outerWidth(),\n      height = item.outerHeight(),\n      offset = item.offset(),\n      sameResultBox = {\n        left: offset.left,\n        right: offset.left + width,\n        top: offset.top,\n        bottom: offset.top + height\n      }\n      if(this.options.vertical){\n        var yCenter = (dim[2] + dim[3]) / 2,\n        inUpperHalf = pointer.top <= yCenter\n        if(inUpperHalf){\n          method = \"before\"\n          sameResultBox.bottom -= height / 2\n        } else\n          sameResultBox.top += height / 2\n      } else {\n        var xCenter = (dim[0] + dim[1]) / 2,\n        inLeftHalf = pointer.left <= xCenter\n        if(inLeftHalf){\n          method = \"before\"\n          sameResultBox.right -= width / 2\n        } else\n          sameResultBox.left += width / 2\n      }\n      if(this.hasChildGroup(index))\n        sameResultBox = emptyBox\n      this.rootGroup.movePlaceholder(this, item, method, sameResultBox)\n    },\n    getItemDimensions: function  () {\n      if(!this.itemDimensions){\n        this.items = this.$getChildren(this.el, \"item\").filter(\n          \":not(.\" + this.group.options.placeholderClass + \", .\" + this.group.options.draggedClass + \")\"\n        ).get()\n        setDimensions(this.items, this.itemDimensions = [], this.options.tolerance)\n      }\n      return this.itemDimensions\n    },\n    getItemOffsetParent: function  () {\n      var offsetParent,\n      el = this.el\n      // Since el might be empty we have to check el itself and\n      // can not do something like el.children().first().offsetParent()\n      if(el.css(\"position\") === \"relative\" || el.css(\"position\") === \"absolute\"  || el.css(\"position\") === \"fixed\")\n        offsetParent = el\n      else\n        offsetParent = el.offsetParent()\n      return offsetParent\n    },\n    hasChildGroup: function (index) {\n      return this.options.nested && this.getContainerGroup(index)\n    },\n    getContainerGroup: function  (index) {\n      var childGroup = $.data(this.items[index], subContainerKey)\n      if( childGroup === undefined){\n        var childContainers = this.$getChildren(this.items[index], \"container\")\n        childGroup = false\n\n        if(childContainers[0]){\n          var options = $.extend({}, this.options, {\n            rootGroup: this.rootGroup,\n            group: groupCounter ++\n          })\n          childGroup = childContainers[pluginName](options).data(pluginName).group\n        }\n        $.data(this.items[index], subContainerKey, childGroup)\n      }\n      return childGroup\n    },\n    $getChildren: function (parent, type) {\n      var options = this.rootGroup.options,\n      path = options[type + \"Path\"],\n      selector = options[type + \"Selector\"]\n\n      parent = $(parent)\n      if(path)\n        parent = parent.find(path)\n\n      return parent.children(selector)\n    },\n    _serialize: function (parent, isContainer) {\n      var that = this,\n      childType = isContainer ? \"item\" : \"container\",\n\n      children = this.$getChildren(parent, childType).not(this.options.exclude).map(function () {\n        return that._serialize($(this), !isContainer)\n      }).get()\n\n      return this.rootGroup.options.serialize(parent, children, isContainer)\n    },\n    traverse: function(callback) {\n      $.each(this.items || [], function(item){\n        var group = $.data(this, subContainerKey)\n        if(group)\n          group.traverse(callback)\n      });\n\n      callback(this)\n    },\n    _clearDimensions: function  () {\n      this.itemDimensions = undefined\n    },\n    _destroy: function() {\n      var that = this;\n\n      this.target.off(eventNames.start, this.handle);\n      this.el.removeData(pluginName)\n\n      if(this.options.drop)\n        this.group.containers = $.grep(this.group.containers, function(val){\n          return val != that\n        })\n\n      $.each(this.items || [], function(){\n        $.removeData(this, subContainerKey)\n      })\n    }\n  }\n\n  var API = {\n    enable: function() {\n      this.traverse(function(object){\n        object.disabled = false\n      })\n    },\n    disable: function (){\n      this.traverse(function(object){\n        object.disabled = true\n      })\n    },\n    serialize: function () {\n      return this._serialize(this.el, true)\n    },\n    refresh: function() {\n      this.traverse(function(object){\n        object._clearDimensions()\n      })\n    },\n    destroy: function () {\n      this.traverse(function(object){\n        object._destroy();\n      })\n    }\n  }\n\n  $.extend(Container.prototype, API)\n\n  /**\n   * jQuery API\n   *\n   * Parameters are\n   *   either options on init\n   *   or a method name followed by arguments to pass to the method\n   */\n  $.fn[pluginName] = function(methodOrOptions) {\n    var args = Array.prototype.slice.call(arguments, 1)\n\n    return this.map(function(){\n      var $t = $(this),\n      object = $t.data(pluginName)\n\n      if(object && API[methodOrOptions])\n        return API[methodOrOptions].apply(object, args) || this\n      else if(!object && (methodOrOptions === undefined ||\n                          typeof methodOrOptions === \"object\"))\n        $t.data(pluginName, new Container($t, methodOrOptions))\n\n      return this\n    });\n  };\n\n}(jQuery, window, 'sortable');\n\n/*!\n * jQuery UI Touch Punch 0.2.3\n *\n * Copyright 2011–2014, Dave Furfero\n * Dual licensed under the MIT or GPL Version 2 licenses.\n *\n * Depends:\n *  jquery.ui.widget.js\n *  jquery.ui.mouse.js\n */\n!function(a){function f(a,b){if(!(a.originalEvent.touches.length>1)){a.preventDefault();var c=a.originalEvent.changedTouches[0],d=document.createEvent(\"MouseEvents\");d.initMouseEvent(b,!0,!0,window,1,c.screenX,c.screenY,c.clientX,c.clientY,!1,!1,!1,!1,0,null),a.target.dispatchEvent(d)}}if(a.support.touch=\"ontouchend\"in document,a.support.touch){var e,b=a.ui.mouse.prototype,c=b._mouseInit,d=b._mouseDestroy;b._touchStart=function(a){var b=this;!e&&b._mouseCapture(a.originalEvent.changedTouches[0])&&(e=!0,b._touchMoved=!1,f(a,\"mouseover\"),f(a,\"mousemove\"),f(a,\"mousedown\"))},b._touchMove=function(a){e&&(this._touchMoved=!0,f(a,\"mousemove\"))},b._touchEnd=function(a){e&&(f(a,\"mouseup\"),f(a,\"mouseout\"),this._touchMoved||f(a,\"click\"),e=!1)},b._mouseInit=function(){var b=this;b.element.bind({touchstart:a.proxy(b,\"_touchStart\"),touchmove:a.proxy(b,\"_touchMove\"),touchend:a.proxy(b,\"_touchEnd\")}),c.call(b)},b._mouseDestroy=function(){var b=this;b.element.unbind({touchstart:a.proxy(b,\"_touchStart\"),touchmove:a.proxy(b,\"_touchMove\"),touchend:a.proxy(b,\"_touchEnd\")}),d.call(b)}}}(jQuery);\n","","var subjects;\nvar subject_1;\nvar subject_2;\nvar subject_3;\n","var voorkeursPartij;\n\nfunction setExample() {\n  var exampleText = ['Per onderwerp krijgt u drie stellingen te zien. Per stelling kunt u vervolgens aangeven hoe belangrijk u die stelling vindt.',\n                     'U kunt de volgorde van de stellingen achteraf nog aanpassen door ze te verschuiven in de lijst die verschijnt.'];\n  var exampleImage = ['dist/images/scherm_example_2.svg', 'dist/images/scherm_example_3.svg'];\n  var placeholderText = document.getElementById('uitleg_text');\n  var placeholderImage = document.getElementById('uitleg_image');\n\n  if(placeholderImage.src === 'https://in60seconds.herokuapp.com/dist/images/scherm_example_1.svg') {\n    placeholderText.innerHTML = exampleText[0];\n    placeholderImage.src = exampleImage[0];\n  } else {\n    placeholderText.innerHTML = exampleText[1];\n    placeholderImage.src = exampleImage[1];\n    document.getElementById('example_btn').style.display = 'none';\n    document.getElementById('example_btn_start').style.display = 'initial';\n  }\n}\n\nfunction stapOneScreen() {\n  document.getElementById('stap-1a').style.display = 'none';\n  document.getElementById('stap-1b').style.display = 'block';\n}\n\nfunction stapTwoScreen() {\n  document.getElementById('stap-2a').style.display = 'none';\n  document.getElementById('voorkeursPartij').innerHTML = localStorage.getItem('voorkeursPartij');\n  document.getElementById('stap-2b').style.display = 'block';\n}\n\nfunction setVoorkeurPartij(partij) {\n  voorkeursPartij = partij;\n  localStorage.setItem('voorkeursPartij', partij);\n  window.location = \"/start/stap-2\";\n}\n"]}